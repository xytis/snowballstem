//! Generated by Snowball 2.0.0 - https://snowballstem.org/

package romanian

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 3, F: nil},
	{Str: "I", A: 0, B: 1, F: nil},
	{Str: "U", A: 0, B: 2, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "ea", A: -1, B: 3, F: nil},
	{Str: "a\u0163ia", A: -1, B: 7, F: nil},
	{Str: "aua", A: -1, B: 2, F: nil},
	{Str: "iua", A: -1, B: 4, F: nil},
	{Str: "a\u0163ie", A: -1, B: 7, F: nil},
	{Str: "ele", A: -1, B: 3, F: nil},
	{Str: "ile", A: -1, B: 5, F: nil},
	{Str: "iile", A: 6, B: 4, F: nil},
	{Str: "iei", A: -1, B: 4, F: nil},
	{Str: "atei", A: -1, B: 6, F: nil},
	{Str: "ii", A: -1, B: 4, F: nil},
	{Str: "ului", A: -1, B: 1, F: nil},
	{Str: "ul", A: -1, B: 1, F: nil},
	{Str: "elor", A: -1, B: 3, F: nil},
	{Str: "ilor", A: -1, B: 4, F: nil},
	{Str: "iilor", A: 14, B: 4, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "icala", A: -1, B: 4, F: nil},
	{Str: "iciva", A: -1, B: 4, F: nil},
	{Str: "ativa", A: -1, B: 5, F: nil},
	{Str: "itiva", A: -1, B: 6, F: nil},
	{Str: "icale", A: -1, B: 4, F: nil},
	{Str: "a\u0163iune", A: -1, B: 5, F: nil},
	{Str: "i\u0163iune", A: -1, B: 6, F: nil},
	{Str: "atoare", A: -1, B: 5, F: nil},
	{Str: "itoare", A: -1, B: 6, F: nil},
	{Str: "\u0103toare", A: -1, B: 5, F: nil},
	{Str: "icitate", A: -1, B: 4, F: nil},
	{Str: "abilitate", A: -1, B: 1, F: nil},
	{Str: "ibilitate", A: -1, B: 2, F: nil},
	{Str: "ivitate", A: -1, B: 3, F: nil},
	{Str: "icive", A: -1, B: 4, F: nil},
	{Str: "ative", A: -1, B: 5, F: nil},
	{Str: "itive", A: -1, B: 6, F: nil},
	{Str: "icali", A: -1, B: 4, F: nil},
	{Str: "atori", A: -1, B: 5, F: nil},
	{Str: "icatori", A: 18, B: 4, F: nil},
	{Str: "itori", A: -1, B: 6, F: nil},
	{Str: "\u0103tori", A: -1, B: 5, F: nil},
	{Str: "icitati", A: -1, B: 4, F: nil},
	{Str: "abilitati", A: -1, B: 1, F: nil},
	{Str: "ivitati", A: -1, B: 3, F: nil},
	{Str: "icivi", A: -1, B: 4, F: nil},
	{Str: "ativi", A: -1, B: 5, F: nil},
	{Str: "itivi", A: -1, B: 6, F: nil},
	{Str: "icit\u0103i", A: -1, B: 4, F: nil},
	{Str: "abilit\u0103i", A: -1, B: 1, F: nil},
	{Str: "ivit\u0103i", A: -1, B: 3, F: nil},
	{Str: "icit\u0103\u0163i", A: -1, B: 4, F: nil},
	{Str: "abilit\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "ivit\u0103\u0163i", A: -1, B: 3, F: nil},
	{Str: "ical", A: -1, B: 4, F: nil},
	{Str: "ator", A: -1, B: 5, F: nil},
	{Str: "icator", A: 35, B: 4, F: nil},
	{Str: "itor", A: -1, B: 6, F: nil},
	{Str: "\u0103tor", A: -1, B: 5, F: nil},
	{Str: "iciv", A: -1, B: 4, F: nil},
	{Str: "ativ", A: -1, B: 5, F: nil},
	{Str: "itiv", A: -1, B: 6, F: nil},
	{Str: "ical\u0103", A: -1, B: 4, F: nil},
	{Str: "iciv\u0103", A: -1, B: 4, F: nil},
	{Str: "ativ\u0103", A: -1, B: 5, F: nil},
	{Str: "itiv\u0103", A: -1, B: 6, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "ica", A: -1, B: 1, F: nil},
	{Str: "abila", A: -1, B: 1, F: nil},
	{Str: "ibila", A: -1, B: 1, F: nil},
	{Str: "oasa", A: -1, B: 1, F: nil},
	{Str: "ata", A: -1, B: 1, F: nil},
	{Str: "ita", A: -1, B: 1, F: nil},
	{Str: "anta", A: -1, B: 1, F: nil},
	{Str: "ista", A: -1, B: 3, F: nil},
	{Str: "uta", A: -1, B: 1, F: nil},
	{Str: "iva", A: -1, B: 1, F: nil},
	{Str: "ic", A: -1, B: 1, F: nil},
	{Str: "ice", A: -1, B: 1, F: nil},
	{Str: "abile", A: -1, B: 1, F: nil},
	{Str: "ibile", A: -1, B: 1, F: nil},
	{Str: "isme", A: -1, B: 3, F: nil},
	{Str: "iune", A: -1, B: 2, F: nil},
	{Str: "oase", A: -1, B: 1, F: nil},
	{Str: "ate", A: -1, B: 1, F: nil},
	{Str: "itate", A: 17, B: 1, F: nil},
	{Str: "ite", A: -1, B: 1, F: nil},
	{Str: "ante", A: -1, B: 1, F: nil},
	{Str: "iste", A: -1, B: 3, F: nil},
	{Str: "ute", A: -1, B: 1, F: nil},
	{Str: "ive", A: -1, B: 1, F: nil},
	{Str: "ici", A: -1, B: 1, F: nil},
	{Str: "abili", A: -1, B: 1, F: nil},
	{Str: "ibili", A: -1, B: 1, F: nil},
	{Str: "iuni", A: -1, B: 2, F: nil},
	{Str: "atori", A: -1, B: 1, F: nil},
	{Str: "osi", A: -1, B: 1, F: nil},
	{Str: "ati", A: -1, B: 1, F: nil},
	{Str: "itati", A: 30, B: 1, F: nil},
	{Str: "iti", A: -1, B: 1, F: nil},
	{Str: "anti", A: -1, B: 1, F: nil},
	{Str: "isti", A: -1, B: 3, F: nil},
	{Str: "uti", A: -1, B: 1, F: nil},
	{Str: "i\u015Fti", A: -1, B: 3, F: nil},
	{Str: "ivi", A: -1, B: 1, F: nil},
	{Str: "it\u0103i", A: -1, B: 1, F: nil},
	{Str: "o\u015Fi", A: -1, B: 1, F: nil},
	{Str: "it\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "abil", A: -1, B: 1, F: nil},
	{Str: "ibil", A: -1, B: 1, F: nil},
	{Str: "ism", A: -1, B: 3, F: nil},
	{Str: "ator", A: -1, B: 1, F: nil},
	{Str: "os", A: -1, B: 1, F: nil},
	{Str: "at", A: -1, B: 1, F: nil},
	{Str: "it", A: -1, B: 1, F: nil},
	{Str: "ant", A: -1, B: 1, F: nil},
	{Str: "ist", A: -1, B: 3, F: nil},
	{Str: "ut", A: -1, B: 1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
	{Str: "ic\u0103", A: -1, B: 1, F: nil},
	{Str: "abil\u0103", A: -1, B: 1, F: nil},
	{Str: "ibil\u0103", A: -1, B: 1, F: nil},
	{Str: "oas\u0103", A: -1, B: 1, F: nil},
	{Str: "at\u0103", A: -1, B: 1, F: nil},
	{Str: "it\u0103", A: -1, B: 1, F: nil},
	{Str: "ant\u0103", A: -1, B: 1, F: nil},
	{Str: "ist\u0103", A: -1, B: 3, F: nil},
	{Str: "ut\u0103", A: -1, B: 1, F: nil},
	{Str: "iv\u0103", A: -1, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ea", A: -1, B: 1, F: nil},
	{Str: "ia", A: -1, B: 1, F: nil},
	{Str: "esc", A: -1, B: 1, F: nil},
	{Str: "\u0103sc", A: -1, B: 1, F: nil},
	{Str: "ind", A: -1, B: 1, F: nil},
	{Str: "\u00E2nd", A: -1, B: 1, F: nil},
	{Str: "are", A: -1, B: 1, F: nil},
	{Str: "ere", A: -1, B: 1, F: nil},
	{Str: "ire", A: -1, B: 1, F: nil},
	{Str: "\u00E2re", A: -1, B: 1, F: nil},
	{Str: "se", A: -1, B: 2, F: nil},
	{Str: "ase", A: 10, B: 1, F: nil},
	{Str: "sese", A: 10, B: 2, F: nil},
	{Str: "ise", A: 10, B: 1, F: nil},
	{Str: "use", A: 10, B: 1, F: nil},
	{Str: "\u00E2se", A: 10, B: 1, F: nil},
	{Str: "e\u015Fte", A: -1, B: 1, F: nil},
	{Str: "\u0103\u015Fte", A: -1, B: 1, F: nil},
	{Str: "eze", A: -1, B: 1, F: nil},
	{Str: "ai", A: -1, B: 1, F: nil},
	{Str: "eai", A: 19, B: 1, F: nil},
	{Str: "iai", A: 19, B: 1, F: nil},
	{Str: "sei", A: -1, B: 2, F: nil},
	{Str: "e\u015Fti", A: -1, B: 1, F: nil},
	{Str: "\u0103\u015Fti", A: -1, B: 1, F: nil},
	{Str: "ui", A: -1, B: 1, F: nil},
	{Str: "ezi", A: -1, B: 1, F: nil},
	{Str: "a\u015Fi", A: -1, B: 1, F: nil},
	{Str: "se\u015Fi", A: -1, B: 2, F: nil},
	{Str: "ase\u015Fi", A: 28, B: 1, F: nil},
	{Str: "sese\u015Fi", A: 28, B: 2, F: nil},
	{Str: "ise\u015Fi", A: 28, B: 1, F: nil},
	{Str: "use\u015Fi", A: 28, B: 1, F: nil},
	{Str: "\u00E2se\u015Fi", A: 28, B: 1, F: nil},
	{Str: "i\u015Fi", A: -1, B: 1, F: nil},
	{Str: "u\u015Fi", A: -1, B: 1, F: nil},
	{Str: "\u00E2\u015Fi", A: -1, B: 1, F: nil},
	{Str: "\u00E2i", A: -1, B: 1, F: nil},
	{Str: "a\u0163i", A: -1, B: 2, F: nil},
	{Str: "ea\u0163i", A: 38, B: 1, F: nil},
	{Str: "ia\u0163i", A: 38, B: 1, F: nil},
	{Str: "e\u0163i", A: -1, B: 2, F: nil},
	{Str: "i\u0163i", A: -1, B: 2, F: nil},
	{Str: "ar\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "ser\u0103\u0163i", A: -1, B: 2, F: nil},
	{Str: "aser\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "seser\u0103\u0163i", A: 44, B: 2, F: nil},
	{Str: "iser\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "user\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "\u00E2ser\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "ir\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "ur\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "\u00E2r\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "\u00E2\u0163i", A: -1, B: 2, F: nil},
	{Str: "am", A: -1, B: 1, F: nil},
	{Str: "eam", A: 54, B: 1, F: nil},
	{Str: "iam", A: 54, B: 1, F: nil},
	{Str: "em", A: -1, B: 2, F: nil},
	{Str: "asem", A: 57, B: 1, F: nil},
	{Str: "sesem", A: 57, B: 2, F: nil},
	{Str: "isem", A: 57, B: 1, F: nil},
	{Str: "usem", A: 57, B: 1, F: nil},
	{Str: "\u00E2sem", A: 57, B: 1, F: nil},
	{Str: "im", A: -1, B: 2, F: nil},
	{Str: "\u0103m", A: -1, B: 2, F: nil},
	{Str: "ar\u0103m", A: 64, B: 1, F: nil},
	{Str: "ser\u0103m", A: 64, B: 2, F: nil},
	{Str: "aser\u0103m", A: 66, B: 1, F: nil},
	{Str: "seser\u0103m", A: 66, B: 2, F: nil},
	{Str: "iser\u0103m", A: 66, B: 1, F: nil},
	{Str: "user\u0103m", A: 66, B: 1, F: nil},
	{Str: "\u00E2ser\u0103m", A: 66, B: 1, F: nil},
	{Str: "ir\u0103m", A: 64, B: 1, F: nil},
	{Str: "ur\u0103m", A: 64, B: 1, F: nil},
	{Str: "\u00E2r\u0103m", A: 64, B: 1, F: nil},
	{Str: "\u00E2m", A: -1, B: 2, F: nil},
	{Str: "au", A: -1, B: 1, F: nil},
	{Str: "eau", A: 76, B: 1, F: nil},
	{Str: "iau", A: 76, B: 1, F: nil},
	{Str: "indu", A: -1, B: 1, F: nil},
	{Str: "\u00E2ndu", A: -1, B: 1, F: nil},
	{Str: "ez", A: -1, B: 1, F: nil},
	{Str: "easc\u0103", A: -1, B: 1, F: nil},
	{Str: "ar\u0103", A: -1, B: 1, F: nil},
	{Str: "ser\u0103", A: -1, B: 2, F: nil},
	{Str: "aser\u0103", A: 84, B: 1, F: nil},
	{Str: "seser\u0103", A: 84, B: 2, F: nil},
	{Str: "iser\u0103", A: 84, B: 1, F: nil},
	{Str: "user\u0103", A: 84, B: 1, F: nil},
	{Str: "\u00E2ser\u0103", A: 84, B: 1, F: nil},
	{Str: "ir\u0103", A: -1, B: 1, F: nil},
	{Str: "ur\u0103", A: -1, B: 1, F: nil},
	{Str: "\u00E2r\u0103", A: -1, B: 1, F: nil},
	{Str: "eaz\u0103", A: -1, B: 1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 1, F: nil},
	{Str: "e", A: -1, B: 1, F: nil},
	{Str: "ie", A: 1, B: 1, F: nil},
	{Str: "i", A: -1, B: 1, F: nil},
	{Str: "\u0103", A: -1, B: 1, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 32, 0, 0, 4}

type Context struct {
	b_standard_suffix_removed bool
	i_p2                      int
	i_p1                      int
	i_pV                      int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
					if !env.InGrouping(G_v, 97, 259) {
						break lab3
					}
					env.Bra = env.Cursor
				lab4:
					for {
						var v_3 = env.Cursor
					lab5:
						for {
							if !env.EqS("u") {
								break lab5
							}
							env.Ket = env.Cursor
							if !env.InGrouping(G_v, 97, 259) {
								break lab5
							}
							if !env.SliceFrom("U") {
								return false
							}
							break lab4
						}
						env.Cursor = v_3
						if !env.EqS("i") {
							break lab3
						}
						env.Ket = env.Cursor
						if !env.InGrouping(G_v, 97, 259) {
							break lab3
						}
						if !env.SliceFrom("I") {
							return false
						}
						break lab4
					}
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	var v_1 = env.Cursor
lab0:
	for {
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				if !env.InGrouping(G_v, 97, 259) {
					break lab2
				}
			lab3:
				for {
					var v_3 = env.Cursor
				lab4:
					for {
						if !env.OutGrouping(G_v, 97, 259) {
							break lab4
						}
					golab5:
						for {
						lab6:
							for {
								if !env.InGrouping(G_v, 97, 259) {
									break lab6
								}
								break golab5
							}
							if env.Cursor >= env.Limit {
								break lab4
							}
							env.NextChar()
						}
						break lab3
					}
					env.Cursor = v_3
					if !env.InGrouping(G_v, 97, 259) {
						break lab2
					}
				golab7:
					for {
					lab8:
						for {
							if !env.OutGrouping(G_v, 97, 259) {
								break lab8
							}
							break golab7
						}
						if env.Cursor >= env.Limit {
							break lab2
						}
						env.NextChar()
					}
					break lab3
				}
				break lab1
			}
			env.Cursor = v_2
			if !env.OutGrouping(G_v, 97, 259) {
				break lab0
			}
		lab9:
			for {
				var v_6 = env.Cursor
			lab10:
				for {
					if !env.OutGrouping(G_v, 97, 259) {
						break lab10
					}
				golab11:
					for {
					lab12:
						for {
							if !env.InGrouping(G_v, 97, 259) {
								break lab12
							}
							break golab11
						}
						if env.Cursor >= env.Limit {
							break lab10
						}
						env.NextChar()
					}
					break lab9
				}
				env.Cursor = v_6
				if !env.InGrouping(G_v, 97, 259) {
					break lab0
				}
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
				break lab9
			}
			break lab1
		}
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	var v_8 = env.Cursor
lab13:
	for {
	golab14:
		for {
		lab15:
			for {
				if !env.InGrouping(G_v, 97, 259) {
					break lab15
				}
				break golab14
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
	golab16:
		for {
		lab17:
			for {
				if !env.OutGrouping(G_v, 97, 259) {
					break lab17
				}
				break golab16
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		context.i_p1 = env.Cursor
	golab18:
		for {
		lab19:
			for {
				if !env.InGrouping(G_v, 97, 259) {
					break lab19
				}
				break golab18
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
	golab20:
		for {
		lab21:
			for {
				if !env.OutGrouping(G_v, 97, 259) {
					break lab21
				}
				break golab20
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		context.i_p2 = env.Cursor
		break lab13
	}
	env.Cursor = v_8
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			env.Bra = env.Cursor
			among_var = env.FindAmong(A_0, context)
			if among_var == 0 {
				break lab1
			}
			env.Ket = env.Cursor
			if among_var == 1 {
				if !env.SliceFrom("i") {
					return false
				}
			} else if among_var == 2 {
				if !env.SliceFrom("u") {
					return false
				}
			} else if among_var == 3 {
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_step_0(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_1, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 4 {
		if !env.SliceFrom("i") {
			return false
		}
	} else if among_var == 5 {
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			if !env.EqSB("ab") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_1
		if !env.SliceFrom("i") {
			return false
		}
	} else if among_var == 6 {
		if !env.SliceFrom("at") {
			return false
		}
	} else if among_var == 7 {
		if !env.SliceFrom("a\u0163i") {
			return false
		}
	}
	return true
}

func r_combo_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	var v_1 = env.Limit - env.Cursor
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_2, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceFrom("abil") {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("ibil") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("iv") {
			return false
		}
	} else if among_var == 4 {
		if !env.SliceFrom("ic") {
			return false
		}
	} else if among_var == 5 {
		if !env.SliceFrom("at") {
			return false
		}
	} else if among_var == 6 {
		if !env.SliceFrom("it") {
			return false
		}
	}
	context.b_standard_suffix_removed = true
	env.Cursor = env.Limit - v_1
	return true
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	context.b_standard_suffix_removed = false
replab0:
	for {
		var v_1 = env.Limit - env.Cursor
	lab1:
		for range [2]struct{}{} {
			if !r_combo_suffix(env, context) {
				break lab1
			}
			continue replab0
		}
		env.Cursor = env.Limit - v_1
		break replab0
	}
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_3, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R2(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.EqSB("\u0163") {
			return false
		}
		env.Bra = env.Cursor
		if !env.SliceFrom("t") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("ist") {
			return false
		}
	}
	context.b_standard_suffix_removed = true
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_pV {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_pV
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	if among_var == 1 {
	lab0:
		for {
			var v_3 = env.Limit - env.Cursor
		lab1:
			for {
				if !env.OutGroupingB(G_v, 97, 259) {
					break lab1
				}
				break lab0
			}
			env.Cursor = env.Limit - v_3
			if !env.EqSB("u") {
				env.LimitBackward = v_2
				return false
			}
			break lab0
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceDel() {
			return false
		}
	}
	env.LimitBackward = v_2
	return true
}

func r_vowel_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_5, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_RV(env, context) {
		return false
	}
	if !env.SliceDel() {
		return false
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		b_standard_suffix_removed: false,
		i_p2:                      0,
		i_p1:                      0,
		i_pV:                      0,
	}
	_ = context
	var v_1 = env.Cursor
	r_prelude(env, context)
	env.Cursor = v_1
	r_mark_regions(env, context)
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_3 = env.Limit - env.Cursor
	r_step_0(env, context)
	env.Cursor = env.Limit - v_3
	var v_4 = env.Limit - env.Cursor
	r_standard_suffix(env, context)
	env.Cursor = env.Limit - v_4
	var v_5 = env.Limit - env.Cursor
lab0:
	for {
	lab1:
		for {
			var v_6 = env.Limit - env.Cursor
		lab2:
			for {
				if !context.b_standard_suffix_removed {
					break lab2
				}
				break lab1
			}
			env.Cursor = env.Limit - v_6
			if !r_verb_suffix(env, context) {
				break lab0
			}
			break lab1
		}
		break lab0
	}
	env.Cursor = env.Limit - v_5
	var v_7 = env.Limit - env.Cursor
	r_vowel_suffix(env, context)
	env.Cursor = env.Limit - v_7
	env.Cursor = env.LimitBackward
	var v_8 = env.Cursor
	r_postlude(env, context)
	env.Cursor = v_8
	return true
}
