//! Generated by Snowball 2.0.0 - https://snowballstem.org/

package portuguese

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 3, F: nil},
	{Str: "\u00E3", A: 0, B: 1, F: nil},
	{Str: "\u00F5", A: 0, B: 2, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 3, F: nil},
	{Str: "a~", A: 0, B: 1, F: nil},
	{Str: "o~", A: 0, B: 2, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: -1, F: nil},
	{Str: "ad", A: -1, B: -1, F: nil},
	{Str: "os", A: -1, B: -1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "ante", A: -1, B: 1, F: nil},
	{Str: "avel", A: -1, B: 1, F: nil},
	{Str: "\u00EDvel", A: -1, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: 1, F: nil},
	{Str: "abil", A: -1, B: 1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "ica", A: -1, B: 1, F: nil},
	{Str: "\u00E2ncia", A: -1, B: 1, F: nil},
	{Str: "\u00EAncia", A: -1, B: 4, F: nil},
	{Str: "logia", A: -1, B: 2, F: nil},
	{Str: "ira", A: -1, B: 9, F: nil},
	{Str: "adora", A: -1, B: 1, F: nil},
	{Str: "osa", A: -1, B: 1, F: nil},
	{Str: "ista", A: -1, B: 1, F: nil},
	{Str: "iva", A: -1, B: 8, F: nil},
	{Str: "eza", A: -1, B: 1, F: nil},
	{Str: "idade", A: -1, B: 7, F: nil},
	{Str: "ante", A: -1, B: 1, F: nil},
	{Str: "mente", A: -1, B: 6, F: nil},
	{Str: "amente", A: 12, B: 5, F: nil},
	{Str: "\u00E1vel", A: -1, B: 1, F: nil},
	{Str: "\u00EDvel", A: -1, B: 1, F: nil},
	{Str: "ico", A: -1, B: 1, F: nil},
	{Str: "ismo", A: -1, B: 1, F: nil},
	{Str: "oso", A: -1, B: 1, F: nil},
	{Str: "amento", A: -1, B: 1, F: nil},
	{Str: "imento", A: -1, B: 1, F: nil},
	{Str: "ivo", A: -1, B: 8, F: nil},
	{Str: "a\u00E7a~o", A: -1, B: 1, F: nil},
	{Str: "u\u00E7a~o", A: -1, B: 3, F: nil},
	{Str: "ador", A: -1, B: 1, F: nil},
	{Str: "icas", A: -1, B: 1, F: nil},
	{Str: "\u00EAncias", A: -1, B: 4, F: nil},
	{Str: "logias", A: -1, B: 2, F: nil},
	{Str: "iras", A: -1, B: 9, F: nil},
	{Str: "adoras", A: -1, B: 1, F: nil},
	{Str: "osas", A: -1, B: 1, F: nil},
	{Str: "istas", A: -1, B: 1, F: nil},
	{Str: "ivas", A: -1, B: 8, F: nil},
	{Str: "ezas", A: -1, B: 1, F: nil},
	{Str: "idades", A: -1, B: 7, F: nil},
	{Str: "adores", A: -1, B: 1, F: nil},
	{Str: "antes", A: -1, B: 1, F: nil},
	{Str: "a\u00E7o~es", A: -1, B: 1, F: nil},
	{Str: "u\u00E7o~es", A: -1, B: 3, F: nil},
	{Str: "icos", A: -1, B: 1, F: nil},
	{Str: "ismos", A: -1, B: 1, F: nil},
	{Str: "osos", A: -1, B: 1, F: nil},
	{Str: "amentos", A: -1, B: 1, F: nil},
	{Str: "imentos", A: -1, B: 1, F: nil},
	{Str: "ivos", A: -1, B: 8, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "ada", A: -1, B: 1, F: nil},
	{Str: "ida", A: -1, B: 1, F: nil},
	{Str: "ia", A: -1, B: 1, F: nil},
	{Str: "aria", A: 2, B: 1, F: nil},
	{Str: "eria", A: 2, B: 1, F: nil},
	{Str: "iria", A: 2, B: 1, F: nil},
	{Str: "ara", A: -1, B: 1, F: nil},
	{Str: "era", A: -1, B: 1, F: nil},
	{Str: "ira", A: -1, B: 1, F: nil},
	{Str: "ava", A: -1, B: 1, F: nil},
	{Str: "asse", A: -1, B: 1, F: nil},
	{Str: "esse", A: -1, B: 1, F: nil},
	{Str: "isse", A: -1, B: 1, F: nil},
	{Str: "aste", A: -1, B: 1, F: nil},
	{Str: "este", A: -1, B: 1, F: nil},
	{Str: "iste", A: -1, B: 1, F: nil},
	{Str: "ei", A: -1, B: 1, F: nil},
	{Str: "arei", A: 16, B: 1, F: nil},
	{Str: "erei", A: 16, B: 1, F: nil},
	{Str: "irei", A: 16, B: 1, F: nil},
	{Str: "am", A: -1, B: 1, F: nil},
	{Str: "iam", A: 20, B: 1, F: nil},
	{Str: "ariam", A: 21, B: 1, F: nil},
	{Str: "eriam", A: 21, B: 1, F: nil},
	{Str: "iriam", A: 21, B: 1, F: nil},
	{Str: "aram", A: 20, B: 1, F: nil},
	{Str: "eram", A: 20, B: 1, F: nil},
	{Str: "iram", A: 20, B: 1, F: nil},
	{Str: "avam", A: 20, B: 1, F: nil},
	{Str: "em", A: -1, B: 1, F: nil},
	{Str: "arem", A: 29, B: 1, F: nil},
	{Str: "erem", A: 29, B: 1, F: nil},
	{Str: "irem", A: 29, B: 1, F: nil},
	{Str: "assem", A: 29, B: 1, F: nil},
	{Str: "essem", A: 29, B: 1, F: nil},
	{Str: "issem", A: 29, B: 1, F: nil},
	{Str: "ado", A: -1, B: 1, F: nil},
	{Str: "ido", A: -1, B: 1, F: nil},
	{Str: "ando", A: -1, B: 1, F: nil},
	{Str: "endo", A: -1, B: 1, F: nil},
	{Str: "indo", A: -1, B: 1, F: nil},
	{Str: "ara~o", A: -1, B: 1, F: nil},
	{Str: "era~o", A: -1, B: 1, F: nil},
	{Str: "ira~o", A: -1, B: 1, F: nil},
	{Str: "ar", A: -1, B: 1, F: nil},
	{Str: "er", A: -1, B: 1, F: nil},
	{Str: "ir", A: -1, B: 1, F: nil},
	{Str: "as", A: -1, B: 1, F: nil},
	{Str: "adas", A: 47, B: 1, F: nil},
	{Str: "idas", A: 47, B: 1, F: nil},
	{Str: "ias", A: 47, B: 1, F: nil},
	{Str: "arias", A: 50, B: 1, F: nil},
	{Str: "erias", A: 50, B: 1, F: nil},
	{Str: "irias", A: 50, B: 1, F: nil},
	{Str: "aras", A: 47, B: 1, F: nil},
	{Str: "eras", A: 47, B: 1, F: nil},
	{Str: "iras", A: 47, B: 1, F: nil},
	{Str: "avas", A: 47, B: 1, F: nil},
	{Str: "es", A: -1, B: 1, F: nil},
	{Str: "ardes", A: 58, B: 1, F: nil},
	{Str: "erdes", A: 58, B: 1, F: nil},
	{Str: "irdes", A: 58, B: 1, F: nil},
	{Str: "ares", A: 58, B: 1, F: nil},
	{Str: "eres", A: 58, B: 1, F: nil},
	{Str: "ires", A: 58, B: 1, F: nil},
	{Str: "asses", A: 58, B: 1, F: nil},
	{Str: "esses", A: 58, B: 1, F: nil},
	{Str: "isses", A: 58, B: 1, F: nil},
	{Str: "astes", A: 58, B: 1, F: nil},
	{Str: "estes", A: 58, B: 1, F: nil},
	{Str: "istes", A: 58, B: 1, F: nil},
	{Str: "is", A: -1, B: 1, F: nil},
	{Str: "ais", A: 71, B: 1, F: nil},
	{Str: "eis", A: 71, B: 1, F: nil},
	{Str: "areis", A: 73, B: 1, F: nil},
	{Str: "ereis", A: 73, B: 1, F: nil},
	{Str: "ireis", A: 73, B: 1, F: nil},
	{Str: "\u00E1reis", A: 73, B: 1, F: nil},
	{Str: "\u00E9reis", A: 73, B: 1, F: nil},
	{Str: "\u00EDreis", A: 73, B: 1, F: nil},
	{Str: "\u00E1sseis", A: 73, B: 1, F: nil},
	{Str: "\u00E9sseis", A: 73, B: 1, F: nil},
	{Str: "\u00EDsseis", A: 73, B: 1, F: nil},
	{Str: "\u00E1veis", A: 73, B: 1, F: nil},
	{Str: "\u00EDeis", A: 73, B: 1, F: nil},
	{Str: "ar\u00EDeis", A: 84, B: 1, F: nil},
	{Str: "er\u00EDeis", A: 84, B: 1, F: nil},
	{Str: "ir\u00EDeis", A: 84, B: 1, F: nil},
	{Str: "ados", A: -1, B: 1, F: nil},
	{Str: "idos", A: -1, B: 1, F: nil},
	{Str: "amos", A: -1, B: 1, F: nil},
	{Str: "\u00E1ramos", A: 90, B: 1, F: nil},
	{Str: "\u00E9ramos", A: 90, B: 1, F: nil},
	{Str: "\u00EDramos", A: 90, B: 1, F: nil},
	{Str: "\u00E1vamos", A: 90, B: 1, F: nil},
	{Str: "\u00EDamos", A: 90, B: 1, F: nil},
	{Str: "ar\u00EDamos", A: 95, B: 1, F: nil},
	{Str: "er\u00EDamos", A: 95, B: 1, F: nil},
	{Str: "ir\u00EDamos", A: 95, B: 1, F: nil},
	{Str: "emos", A: -1, B: 1, F: nil},
	{Str: "aremos", A: 99, B: 1, F: nil},
	{Str: "eremos", A: 99, B: 1, F: nil},
	{Str: "iremos", A: 99, B: 1, F: nil},
	{Str: "\u00E1ssemos", A: 99, B: 1, F: nil},
	{Str: "\u00EAssemos", A: 99, B: 1, F: nil},
	{Str: "\u00EDssemos", A: 99, B: 1, F: nil},
	{Str: "imos", A: -1, B: 1, F: nil},
	{Str: "armos", A: -1, B: 1, F: nil},
	{Str: "ermos", A: -1, B: 1, F: nil},
	{Str: "irmos", A: -1, B: 1, F: nil},
	{Str: "\u00E1mos", A: -1, B: 1, F: nil},
	{Str: "ar\u00E1s", A: -1, B: 1, F: nil},
	{Str: "er\u00E1s", A: -1, B: 1, F: nil},
	{Str: "ir\u00E1s", A: -1, B: 1, F: nil},
	{Str: "eu", A: -1, B: 1, F: nil},
	{Str: "iu", A: -1, B: 1, F: nil},
	{Str: "ou", A: -1, B: 1, F: nil},
	{Str: "ar\u00E1", A: -1, B: 1, F: nil},
	{Str: "er\u00E1", A: -1, B: 1, F: nil},
	{Str: "ir\u00E1", A: -1, B: 1, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 1, F: nil},
	{Str: "i", A: -1, B: 1, F: nil},
	{Str: "o", A: -1, B: 1, F: nil},
	{Str: "os", A: -1, B: 1, F: nil},
	{Str: "\u00E1", A: -1, B: 1, F: nil},
	{Str: "\u00ED", A: -1, B: 1, F: nil},
	{Str: "\u00F3", A: -1, B: 1, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "e", A: -1, B: 1, F: nil},
	{Str: "\u00E7", A: -1, B: 2, F: nil},
	{Str: "\u00E9", A: -1, B: 1, F: nil},
	{Str: "\u00EA", A: -1, B: 1, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 19, 12, 2}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			env.Bra = env.Cursor
			among_var = env.FindAmong(A_0, context)
			if among_var == 0 {
				break lab1
			}
			env.Ket = env.Cursor
			if among_var == 1 {
				if !env.SliceFrom("a~") {
					return false
				}
			} else if among_var == 2 {
				if !env.SliceFrom("o~") {
					return false
				}
			} else if among_var == 3 {
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	var v_1 = env.Cursor
lab0:
	for {
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab2
				}
			lab3:
				for {
					var v_3 = env.Cursor
				lab4:
					for {
						if !env.OutGrouping(G_v, 97, 250) {
							break lab4
						}
					golab5:
						for {
						lab6:
							for {
								if !env.InGrouping(G_v, 97, 250) {
									break lab6
								}
								break golab5
							}
							if env.Cursor >= env.Limit {
								break lab4
							}
							env.NextChar()
						}
						break lab3
					}
					env.Cursor = v_3
					if !env.InGrouping(G_v, 97, 250) {
						break lab2
					}
				golab7:
					for {
					lab8:
						for {
							if !env.OutGrouping(G_v, 97, 250) {
								break lab8
							}
							break golab7
						}
						if env.Cursor >= env.Limit {
							break lab2
						}
						env.NextChar()
					}
					break lab3
				}
				break lab1
			}
			env.Cursor = v_2
			if !env.OutGrouping(G_v, 97, 250) {
				break lab0
			}
		lab9:
			for {
				var v_6 = env.Cursor
			lab10:
				for {
					if !env.OutGrouping(G_v, 97, 250) {
						break lab10
					}
				golab11:
					for {
					lab12:
						for {
							if !env.InGrouping(G_v, 97, 250) {
								break lab12
							}
							break golab11
						}
						if env.Cursor >= env.Limit {
							break lab10
						}
						env.NextChar()
					}
					break lab9
				}
				env.Cursor = v_6
				if !env.InGrouping(G_v, 97, 250) {
					break lab0
				}
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
				break lab9
			}
			break lab1
		}
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	var v_8 = env.Cursor
lab13:
	for {
	golab14:
		for {
		lab15:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab15
				}
				break golab14
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
	golab16:
		for {
		lab17:
			for {
				if !env.OutGrouping(G_v, 97, 250) {
					break lab17
				}
				break golab16
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		context.i_p1 = env.Cursor
	golab18:
		for {
		lab19:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab19
				}
				break golab18
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
	golab20:
		for {
		lab21:
			for {
				if !env.OutGrouping(G_v, 97, 250) {
					break lab21
				}
				break golab20
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		context.i_p2 = env.Cursor
		break lab13
	}
	env.Cursor = v_8
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			env.Bra = env.Cursor
			among_var = env.FindAmong(A_1, context)
			if among_var == 0 {
				break lab1
			}
			env.Ket = env.Cursor
			if among_var == 1 {
				if !env.SliceFrom("\u00E3") {
					return false
				}
			} else if among_var == 2 {
				if !env.SliceFrom("\u00F5") {
					return false
				}
			} else if among_var == 3 {
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_5, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if among_var == 1 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceFrom("log") {
			return false
		}
	} else if among_var == 3 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceFrom("u") {
			return false
		}
	} else if among_var == 4 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceFrom("ente") {
			return false
		}
	} else if among_var == 5 {
		if !r_R1(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			env.Ket = env.Cursor
			among_var = env.FindAmongB(A_2, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			env.Bra = env.Cursor
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			if !env.SliceDel() {
				return false
			}
			if among_var == 1 {
				env.Ket = env.Cursor
				if !env.EqSB("at") {
					env.Cursor = env.Limit - v_1
					break lab0
				}
				env.Bra = env.Cursor
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_1
					break lab0
				}
				if !env.SliceDel() {
					return false
				}
			}
			break lab0
		}
	} else if among_var == 6 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
		var v_2 = env.Limit - env.Cursor
	lab1:
		for {
			env.Ket = env.Cursor
			if env.FindAmongB(A_3, context) == 0 {
				env.Cursor = env.Limit - v_2
				break lab1
			}
			env.Bra = env.Cursor
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_2
				break lab1
			}
			if !env.SliceDel() {
				return false
			}
			break lab1
		}
	} else if among_var == 7 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
		var v_3 = env.Limit - env.Cursor
	lab2:
		for {
			env.Ket = env.Cursor
			if env.FindAmongB(A_4, context) == 0 {
				env.Cursor = env.Limit - v_3
				break lab2
			}
			env.Bra = env.Cursor
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_3
				break lab2
			}
			if !env.SliceDel() {
				return false
			}
			break lab2
		}
	} else if among_var == 8 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
		var v_4 = env.Limit - env.Cursor
	lab3:
		for {
			env.Ket = env.Cursor
			if !env.EqSB("at") {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			env.Bra = env.Cursor
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			if !env.SliceDel() {
				return false
			}
			break lab3
		}
	} else if among_var == 9 {
		if !r_RV(env, context) {
			return false
		}
		if !env.EqSB("e") {
			return false
		}
		if !env.SliceFrom("ir") {
			return false
		}
	}
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if env.Cursor < context.i_pV {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_pV
	env.Ket = env.Cursor
	if env.FindAmongB(A_6, context) == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	if !env.SliceDel() {
		return false
	}
	env.LimitBackward = v_2
	return true
}

func r_residual_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_7, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_RV(env, context) {
		return false
	}
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_residual_form(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_8, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if among_var == 1 {
		if !r_RV(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
		env.Ket = env.Cursor
	lab0:
		for {
			var v_1 = env.Limit - env.Cursor
		lab1:
			for {
				if !env.EqSB("u") {
					break lab1
				}
				env.Bra = env.Cursor
				var v_2 = env.Limit - env.Cursor
				if !env.EqSB("g") {
					break lab1
				}
				env.Cursor = env.Limit - v_2
				break lab0
			}
			env.Cursor = env.Limit - v_1
			if !env.EqSB("i") {
				return false
			}
			env.Bra = env.Cursor
			var v_3 = env.Limit - env.Cursor
			if !env.EqSB("c") {
				return false
			}
			env.Cursor = env.Limit - v_3
			break lab0
		}
		if !r_RV(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("c") {
			return false
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	var v_1 = env.Cursor
	r_prelude(env, context)
	env.Cursor = v_1
	r_mark_regions(env, context)
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_3 = env.Limit - env.Cursor
lab0:
	for {
	lab1:
		for {
			var v_4 = env.Limit - env.Cursor
		lab2:
			for {
				var v_5 = env.Limit - env.Cursor
			lab3:
				for {
					var v_6 = env.Limit - env.Cursor
				lab4:
					for {
						if !r_standard_suffix(env, context) {
							break lab4
						}
						break lab3
					}
					env.Cursor = env.Limit - v_6
					if !r_verb_suffix(env, context) {
						break lab2
					}
					break lab3
				}
				env.Cursor = env.Limit - v_5
				var v_7 = env.Limit - env.Cursor
			lab5:
				for {
					env.Ket = env.Cursor
					if !env.EqSB("i") {
						break lab5
					}
					env.Bra = env.Cursor
					var v_8 = env.Limit - env.Cursor
					if !env.EqSB("c") {
						break lab5
					}
					env.Cursor = env.Limit - v_8
					if !r_RV(env, context) {
						break lab5
					}
					if !env.SliceDel() {
						return false
					}
					break lab5
				}
				env.Cursor = env.Limit - v_7
				break lab1
			}
			env.Cursor = env.Limit - v_4
			if !r_residual_suffix(env, context) {
				break lab0
			}
			break lab1
		}
		break lab0
	}
	env.Cursor = env.Limit - v_3
	var v_9 = env.Limit - env.Cursor
	r_residual_form(env, context)
	env.Cursor = env.Limit - v_9
	env.Cursor = env.LimitBackward
	var v_10 = env.Cursor
	r_postlude(env, context)
	env.Cursor = v_10
	return true
}
