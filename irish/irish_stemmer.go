//! Generated by Snowball 2.0.0 - https://snowballstem.org/

package irish

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "b'", A: -1, B: 1, F: nil},
	{Str: "bh", A: -1, B: 4, F: nil},
	{Str: "bhf", A: 1, B: 2, F: nil},
	{Str: "bp", A: -1, B: 8, F: nil},
	{Str: "ch", A: -1, B: 5, F: nil},
	{Str: "d'", A: -1, B: 1, F: nil},
	{Str: "d'fh", A: 5, B: 2, F: nil},
	{Str: "dh", A: -1, B: 6, F: nil},
	{Str: "dt", A: -1, B: 9, F: nil},
	{Str: "fh", A: -1, B: 2, F: nil},
	{Str: "gc", A: -1, B: 5, F: nil},
	{Str: "gh", A: -1, B: 7, F: nil},
	{Str: "h-", A: -1, B: 1, F: nil},
	{Str: "m'", A: -1, B: 1, F: nil},
	{Str: "mb", A: -1, B: 4, F: nil},
	{Str: "mh", A: -1, B: 10, F: nil},
	{Str: "n-", A: -1, B: 1, F: nil},
	{Str: "nd", A: -1, B: 6, F: nil},
	{Str: "ng", A: -1, B: 7, F: nil},
	{Str: "ph", A: -1, B: 8, F: nil},
	{Str: "sh", A: -1, B: 3, F: nil},
	{Str: "t-", A: -1, B: 1, F: nil},
	{Str: "th", A: -1, B: 9, F: nil},
	{Str: "ts", A: -1, B: 3, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "\u00EDochta", A: -1, B: 1, F: nil},
	{Str: "a\u00EDochta", A: 0, B: 1, F: nil},
	{Str: "ire", A: -1, B: 2, F: nil},
	{Str: "aire", A: 2, B: 2, F: nil},
	{Str: "abh", A: -1, B: 1, F: nil},
	{Str: "eabh", A: 4, B: 1, F: nil},
	{Str: "ibh", A: -1, B: 1, F: nil},
	{Str: "aibh", A: 6, B: 1, F: nil},
	{Str: "amh", A: -1, B: 1, F: nil},
	{Str: "eamh", A: 8, B: 1, F: nil},
	{Str: "imh", A: -1, B: 1, F: nil},
	{Str: "aimh", A: 10, B: 1, F: nil},
	{Str: "\u00EDocht", A: -1, B: 1, F: nil},
	{Str: "a\u00EDocht", A: 12, B: 1, F: nil},
	{Str: "ir\u00ED", A: -1, B: 2, F: nil},
	{Str: "air\u00ED", A: 14, B: 2, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "\u00F3ideacha", A: -1, B: 6, F: nil},
	{Str: "patacha", A: -1, B: 5, F: nil},
	{Str: "achta", A: -1, B: 1, F: nil},
	{Str: "arcachta", A: 2, B: 2, F: nil},
	{Str: "eachta", A: 2, B: 1, F: nil},
	{Str: "grafa\u00EDochta", A: -1, B: 4, F: nil},
	{Str: "paite", A: -1, B: 5, F: nil},
	{Str: "ach", A: -1, B: 1, F: nil},
	{Str: "each", A: 7, B: 1, F: nil},
	{Str: "\u00F3ideach", A: 8, B: 6, F: nil},
	{Str: "gineach", A: 8, B: 3, F: nil},
	{Str: "patach", A: 7, B: 5, F: nil},
	{Str: "grafa\u00EDoch", A: -1, B: 4, F: nil},
	{Str: "pataigh", A: -1, B: 5, F: nil},
	{Str: "\u00F3idigh", A: -1, B: 6, F: nil},
	{Str: "acht\u00FAil", A: -1, B: 1, F: nil},
	{Str: "eacht\u00FAil", A: 15, B: 1, F: nil},
	{Str: "gineas", A: -1, B: 3, F: nil},
	{Str: "ginis", A: -1, B: 3, F: nil},
	{Str: "acht", A: -1, B: 1, F: nil},
	{Str: "arcacht", A: 19, B: 2, F: nil},
	{Str: "eacht", A: 19, B: 1, F: nil},
	{Str: "grafa\u00EDocht", A: -1, B: 4, F: nil},
	{Str: "arcachta\u00ED", A: -1, B: 2, F: nil},
	{Str: "grafa\u00EDochta\u00ED", A: -1, B: 4, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "imid", A: -1, B: 1, F: nil},
	{Str: "aimid", A: 0, B: 1, F: nil},
	{Str: "\u00EDmid", A: -1, B: 1, F: nil},
	{Str: "a\u00EDmid", A: 2, B: 1, F: nil},
	{Str: "adh", A: -1, B: 2, F: nil},
	{Str: "eadh", A: 4, B: 2, F: nil},
	{Str: "faidh", A: -1, B: 1, F: nil},
	{Str: "fidh", A: -1, B: 1, F: nil},
	{Str: "\u00E1il", A: -1, B: 2, F: nil},
	{Str: "ain", A: -1, B: 2, F: nil},
	{Str: "tear", A: -1, B: 2, F: nil},
	{Str: "tar", A: -1, B: 2, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 2}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	var v_1 = env.Cursor
lab0:
	for {
	golab1:
		for {
		lab2:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab2
				}
				break golab1
			}
			if env.Cursor >= env.Limit {
				break lab0
			}
			env.NextChar()
		}
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	var v_3 = env.Cursor
lab3:
	for {
	golab4:
		for {
		lab5:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab5
				}
				break golab4
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
	golab6:
		for {
		lab7:
			for {
				if !env.OutGrouping(G_v, 97, 250) {
					break lab7
				}
				break golab6
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
		context.i_p1 = env.Cursor
	golab8:
		for {
		lab9:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab9
				}
				break golab8
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
	golab10:
		for {
		lab11:
			for {
				if !env.OutGrouping(G_v, 97, 250) {
					break lab11
				}
				break golab10
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
		context.i_p2 = env.Cursor
		break lab3
	}
	env.Cursor = v_3
	return true
}

func r_initial_morph(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Bra = env.Cursor
	among_var = env.FindAmong(A_0, context)
	if among_var == 0 {
		return false
	}
	env.Ket = env.Cursor
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("f") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("s") {
			return false
		}
	} else if among_var == 4 {
		if !env.SliceFrom("b") {
			return false
		}
	} else if among_var == 5 {
		if !env.SliceFrom("c") {
			return false
		}
	} else if among_var == 6 {
		if !env.SliceFrom("d") {
			return false
		}
	} else if among_var == 7 {
		if !env.SliceFrom("g") {
			return false
		}
	} else if among_var == 8 {
		if !env.SliceFrom("p") {
			return false
		}
	} else if among_var == 9 {
		if !env.SliceFrom("t") {
			return false
		}
	} else if among_var == 10 {
		if !env.SliceFrom("m") {
			return false
		}
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_noun_sfx(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_1, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if among_var == 1 {
		if !r_R1(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_deriv(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_2, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if among_var == 1 {
		if !r_R2(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("arc") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("gin") {
			return false
		}
	} else if among_var == 4 {
		if !env.SliceFrom("graf") {
			return false
		}
	} else if among_var == 5 {
		if !env.SliceFrom("paite") {
			return false
		}
	} else if among_var == 6 {
		if !env.SliceFrom("\u00F3id") {
			return false
		}
	}
	return true
}

func r_verb_sfx(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_3, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if among_var == 1 {
		if !r_RV(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !r_R1(env, context) {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	var v_1 = env.Cursor
	r_initial_morph(env, context)
	env.Cursor = v_1
	r_mark_regions(env, context)
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_3 = env.Limit - env.Cursor
	r_noun_sfx(env, context)
	env.Cursor = env.Limit - v_3
	var v_4 = env.Limit - env.Cursor
	r_deriv(env, context)
	env.Cursor = env.Limit - v_4
	var v_5 = env.Limit - env.Cursor
	r_verb_sfx(env, context)
	env.Cursor = env.Limit - v_5
	env.Cursor = env.LimitBackward
	return true
}
