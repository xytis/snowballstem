//! Generated by Snowball 2.0.0 - https://snowballstem.org/

package indonesian

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "kah", A: -1, B: 1, F: nil},
	{Str: "lah", A: -1, B: 1, F: nil},
	{Str: "pun", A: -1, B: 1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "nya", A: -1, B: 1, F: nil},
	{Str: "ku", A: -1, B: 1, F: nil},
	{Str: "mu", A: -1, B: 1, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "i", A: -1, B: 1, F: r_SUFFIX_I_OK},
	{Str: "an", A: -1, B: 1, F: r_SUFFIX_AN_OK},
	{Str: "kan", A: 1, B: 1, F: r_SUFFIX_KAN_OK},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "di", A: -1, B: 1, F: nil},
	{Str: "ke", A: -1, B: 2, F: nil},
	{Str: "me", A: -1, B: 1, F: nil},
	{Str: "mem", A: 2, B: 5, F: nil},
	{Str: "men", A: 2, B: 1, F: nil},
	{Str: "meng", A: 4, B: 1, F: nil},
	{Str: "meny", A: 4, B: 3, F: r_VOWEL},
	{Str: "pem", A: -1, B: 6, F: nil},
	{Str: "pen", A: -1, B: 2, F: nil},
	{Str: "peng", A: 8, B: 2, F: nil},
	{Str: "peny", A: 8, B: 4, F: r_VOWEL},
	{Str: "ter", A: -1, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "be", A: -1, B: 3, F: r_KER},
	{Str: "belajar", A: 0, B: 4, F: nil},
	{Str: "ber", A: 0, B: 3, F: nil},
	{Str: "pe", A: -1, B: 1, F: nil},
	{Str: "pelajar", A: 3, B: 2, F: nil},
	{Str: "per", A: 3, B: 1, F: nil},
}

var G_vowel = []byte{17, 65, 16}

type Context struct {
	i_prefix  int
	i_measure int
}

func r_remove_particle(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_0, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !env.SliceDel() {
		return false
	}
	context.i_measure -= 1
	return true
}

func r_remove_possessive_pronoun(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_1, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !env.SliceDel() {
		return false
	}
	context.i_measure -= 1
	return true
}

func r_SUFFIX_KAN_OK(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_prefix != 3) {
		return false
	}
	if !(context.i_prefix != 2) {
		return false
	}
	return true
}

func r_SUFFIX_AN_OK(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_prefix != 1) {
		return false
	}
	return true
}

func r_SUFFIX_I_OK(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_prefix <= 2) {
		return false
	}
	var v_1 = env.Limit - env.Cursor
lab0:
	for {
		if !env.EqSB("s") {
			break lab0
		}
		return false
	}
	env.Cursor = env.Limit - v_1
	return true
}

func r_remove_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_2, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !env.SliceDel() {
		return false
	}
	context.i_measure -= 1
	return true
}

func r_VOWEL(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !env.InGrouping(G_vowel, 97, 117) {
		return false
	}
	return true
}

func r_KER(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !env.OutGrouping(G_vowel, 97, 117) {
		return false
	}
	if !env.EqS("er") {
		return false
	}
	return true
}

func r_remove_first_order_prefix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Bra = env.Cursor
	among_var = env.FindAmong(A_3, context)
	if among_var == 0 {
		return false
	}
	env.Ket = env.Cursor
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
		context.i_prefix = 1
		context.i_measure -= 1
	} else if among_var == 2 {
		if !env.SliceDel() {
			return false
		}
		context.i_prefix = 3
		context.i_measure -= 1
	} else if among_var == 3 {
		context.i_prefix = 1
		if !env.SliceFrom("s") {
			return false
		}
		context.i_measure -= 1
	} else if among_var == 4 {
		context.i_prefix = 3
		if !env.SliceFrom("s") {
			return false
		}
		context.i_measure -= 1
	} else if among_var == 5 {
		context.i_prefix = 1
		context.i_measure -= 1
	lab0:
		for {
			var v_1 = env.Cursor
		lab1:
			for {
				var v_2 = env.Cursor
				if !env.InGrouping(G_vowel, 97, 117) {
					break lab1
				}
				env.Cursor = v_2
				if !env.SliceFrom("p") {
					return false
				}
				break lab0
			}
			env.Cursor = v_1
			if !env.SliceDel() {
				return false
			}
			break lab0
		}
	} else if among_var == 6 {
		context.i_prefix = 3
		context.i_measure -= 1
	lab2:
		for {
			var v_3 = env.Cursor
		lab3:
			for {
				var v_4 = env.Cursor
				if !env.InGrouping(G_vowel, 97, 117) {
					break lab3
				}
				env.Cursor = v_4
				if !env.SliceFrom("p") {
					return false
				}
				break lab2
			}
			env.Cursor = v_3
			if !env.SliceDel() {
				return false
			}
			break lab2
		}
	}
	return true
}

func r_remove_second_order_prefix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Bra = env.Cursor
	among_var = env.FindAmong(A_4, context)
	if among_var == 0 {
		return false
	}
	env.Ket = env.Cursor
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
		context.i_prefix = 2
		context.i_measure -= 1
	} else if among_var == 2 {
		if !env.SliceFrom("ajar") {
			return false
		}
		context.i_measure -= 1
	} else if among_var == 3 {
		if !env.SliceDel() {
			return false
		}
		context.i_prefix = 4
		context.i_measure -= 1
	} else if among_var == 4 {
		if !env.SliceFrom("ajar") {
			return false
		}
		context.i_prefix = 4
		context.i_measure -= 1
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_prefix:  0,
		i_measure: 0,
	}
	_ = context
	context.i_measure = 0
	var v_1 = env.Cursor
lab0:
	for {
	replab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for range [2]struct{}{} {
			golab3:
				for {
				lab4:
					for {
						if !env.InGrouping(G_vowel, 97, 117) {
							break lab4
						}
						break golab3
					}
					if env.Cursor >= env.Limit {
						break lab2
					}
					env.NextChar()
				}
				context.i_measure += 1
				continue replab1
			}
			env.Cursor = v_2
			break replab1
		}
		break lab0
	}
	env.Cursor = v_1
	if !(context.i_measure > 2) {
		return false
	}
	context.i_prefix = 0
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_4 = env.Limit - env.Cursor
	r_remove_particle(env, context)
	env.Cursor = env.Limit - v_4
	if !(context.i_measure > 2) {
		return false
	}
	var v_5 = env.Limit - env.Cursor
	r_remove_possessive_pronoun(env, context)
	env.Cursor = env.Limit - v_5
	env.Cursor = env.LimitBackward
	if !(context.i_measure > 2) {
		return false
	}
lab5:
	for {
		var v_6 = env.Cursor
	lab6:
		for {
			var v_7 = env.Cursor
			if !r_remove_first_order_prefix(env, context) {
				break lab6
			}
			var v_8 = env.Cursor
		lab7:
			for {
				var v_9 = env.Cursor
				if !(context.i_measure > 2) {
					break lab7
				}
				env.LimitBackward = env.Cursor
				env.Cursor = env.Limit
				if !r_remove_suffix(env, context) {
					break lab7
				}
				env.Cursor = env.LimitBackward
				env.Cursor = v_9
				if !(context.i_measure > 2) {
					break lab7
				}
				if !r_remove_second_order_prefix(env, context) {
					break lab7
				}
				break lab7
			}
			env.Cursor = v_8
			env.Cursor = v_7
			break lab5
		}
		env.Cursor = v_6
		var v_10 = env.Cursor
		r_remove_second_order_prefix(env, context)
		env.Cursor = v_10
		var v_11 = env.Cursor
	lab8:
		for {
			if !(context.i_measure > 2) {
				break lab8
			}
			env.LimitBackward = env.Cursor
			env.Cursor = env.Limit
			if !r_remove_suffix(env, context) {
				break lab8
			}
			env.Cursor = env.LimitBackward
			break lab8
		}
		env.Cursor = v_11
		break lab5
	}
	return true
}
