//! Generated by Snowball 2.0.0 - https://snowballstem.org/

package finnish

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "pa", A: -1, B: 1, F: nil},
	{Str: "sti", A: -1, B: 2, F: nil},
	{Str: "kaan", A: -1, B: 1, F: nil},
	{Str: "han", A: -1, B: 1, F: nil},
	{Str: "kin", A: -1, B: 1, F: nil},
	{Str: "h\u00E4n", A: -1, B: 1, F: nil},
	{Str: "k\u00E4\u00E4n", A: -1, B: 1, F: nil},
	{Str: "ko", A: -1, B: 1, F: nil},
	{Str: "p\u00E4", A: -1, B: 1, F: nil},
	{Str: "k\u00F6", A: -1, B: 1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "lla", A: -1, B: -1, F: nil},
	{Str: "na", A: -1, B: -1, F: nil},
	{Str: "ssa", A: -1, B: -1, F: nil},
	{Str: "ta", A: -1, B: -1, F: nil},
	{Str: "lta", A: 3, B: -1, F: nil},
	{Str: "sta", A: 3, B: -1, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "ll\u00E4", A: -1, B: -1, F: nil},
	{Str: "n\u00E4", A: -1, B: -1, F: nil},
	{Str: "ss\u00E4", A: -1, B: -1, F: nil},
	{Str: "t\u00E4", A: -1, B: -1, F: nil},
	{Str: "lt\u00E4", A: 3, B: -1, F: nil},
	{Str: "st\u00E4", A: 3, B: -1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "lle", A: -1, B: -1, F: nil},
	{Str: "ine", A: -1, B: -1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "nsa", A: -1, B: 3, F: nil},
	{Str: "mme", A: -1, B: 3, F: nil},
	{Str: "nne", A: -1, B: 3, F: nil},
	{Str: "ni", A: -1, B: 2, F: nil},
	{Str: "si", A: -1, B: 1, F: nil},
	{Str: "an", A: -1, B: 4, F: nil},
	{Str: "en", A: -1, B: 6, F: nil},
	{Str: "\u00E4n", A: -1, B: 5, F: nil},
	{Str: "ns\u00E4", A: -1, B: 3, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "aa", A: -1, B: -1, F: nil},
	{Str: "ee", A: -1, B: -1, F: nil},
	{Str: "ii", A: -1, B: -1, F: nil},
	{Str: "oo", A: -1, B: -1, F: nil},
	{Str: "uu", A: -1, B: -1, F: nil},
	{Str: "\u00E4\u00E4", A: -1, B: -1, F: nil},
	{Str: "\u00F6\u00F6", A: -1, B: -1, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 8, F: nil},
	{Str: "lla", A: 0, B: -1, F: nil},
	{Str: "na", A: 0, B: -1, F: nil},
	{Str: "ssa", A: 0, B: -1, F: nil},
	{Str: "ta", A: 0, B: -1, F: nil},
	{Str: "lta", A: 4, B: -1, F: nil},
	{Str: "sta", A: 4, B: -1, F: nil},
	{Str: "tta", A: 4, B: 2, F: nil},
	{Str: "lle", A: -1, B: -1, F: nil},
	{Str: "ine", A: -1, B: -1, F: nil},
	{Str: "ksi", A: -1, B: -1, F: nil},
	{Str: "n", A: -1, B: 7, F: nil},
	{Str: "han", A: 11, B: 1, F: nil},
	{Str: "den", A: 11, B: -1, F: r_VI},
	{Str: "seen", A: 11, B: -1, F: r_LONG},
	{Str: "hen", A: 11, B: 2, F: nil},
	{Str: "tten", A: 11, B: -1, F: r_VI},
	{Str: "hin", A: 11, B: 3, F: nil},
	{Str: "siin", A: 11, B: -1, F: r_VI},
	{Str: "hon", A: 11, B: 4, F: nil},
	{Str: "h\u00E4n", A: 11, B: 5, F: nil},
	{Str: "h\u00F6n", A: 11, B: 6, F: nil},
	{Str: "\u00E4", A: -1, B: 8, F: nil},
	{Str: "ll\u00E4", A: 22, B: -1, F: nil},
	{Str: "n\u00E4", A: 22, B: -1, F: nil},
	{Str: "ss\u00E4", A: 22, B: -1, F: nil},
	{Str: "t\u00E4", A: 22, B: -1, F: nil},
	{Str: "lt\u00E4", A: 26, B: -1, F: nil},
	{Str: "st\u00E4", A: 26, B: -1, F: nil},
	{Str: "tt\u00E4", A: 26, B: 2, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "eja", A: -1, B: -1, F: nil},
	{Str: "mma", A: -1, B: 1, F: nil},
	{Str: "imma", A: 1, B: -1, F: nil},
	{Str: "mpa", A: -1, B: 1, F: nil},
	{Str: "impa", A: 3, B: -1, F: nil},
	{Str: "mmi", A: -1, B: 1, F: nil},
	{Str: "immi", A: 5, B: -1, F: nil},
	{Str: "mpi", A: -1, B: 1, F: nil},
	{Str: "impi", A: 7, B: -1, F: nil},
	{Str: "ej\u00E4", A: -1, B: -1, F: nil},
	{Str: "mm\u00E4", A: -1, B: 1, F: nil},
	{Str: "imm\u00E4", A: 10, B: -1, F: nil},
	{Str: "mp\u00E4", A: -1, B: 1, F: nil},
	{Str: "imp\u00E4", A: 12, B: -1, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "i", A: -1, B: -1, F: nil},
	{Str: "j", A: -1, B: -1, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	{Str: "mma", A: -1, B: 1, F: nil},
	{Str: "imma", A: 0, B: -1, F: nil},
}

var G_AEI = []byte{17, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8}

var G_C = []byte{119, 223, 119, 1}

var G_V1 = []byte{17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32}

var G_V2 = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32}

var G_particle_end = []byte{17, 97, 24, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32}

type Context struct {
	b_ending_removed bool
	S_x              string
	i_p2             int
	i_p1             int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
golab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for {
			if !env.InGrouping(G_V1, 97, 246) {
				break lab1
			}
			env.Cursor = v_1
			break golab0
		}
		env.Cursor = v_1
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
golab2:
	for {
	lab3:
		for {
			if !env.OutGrouping(G_V1, 97, 246) {
				break lab3
			}
			break golab2
		}
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
	context.i_p1 = env.Cursor
golab4:
	for {
		var v_3 = env.Cursor
	lab5:
		for {
			if !env.InGrouping(G_V1, 97, 246) {
				break lab5
			}
			env.Cursor = v_3
			break golab4
		}
		env.Cursor = v_3
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
golab6:
	for {
	lab7:
		for {
			if !env.OutGrouping(G_V1, 97, 246) {
				break lab7
			}
			break golab6
		}
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
	context.i_p2 = env.Cursor
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_particle_etc(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_p1 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p1
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_0, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 1 {
		if !env.InGroupingB(G_particle_end, 97, 246) {
			return false
		}
	} else if among_var == 2 {
		if !r_R2(env, context) {
			return false
		}
	}
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_possessive(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_p1 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p1
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 1 {
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			if !env.EqSB("k") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_3
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceDel() {
			return false
		}
		env.Ket = env.Cursor
		if !env.EqSB("kse") {
			return false
		}
		env.Bra = env.Cursor
		if !env.SliceFrom("ksi") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 4 {
		if env.FindAmongB(A_1, context) == 0 {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		if env.FindAmongB(A_2, context) == 0 {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 6 {
		if env.FindAmongB(A_3, context) == 0 {
			return false
		}
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_LONG(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if env.FindAmongB(A_5, context) == 0 {
		return false
	}
	return true
}

func r_VI(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !env.EqSB("i") {
		return false
	}
	if !env.InGroupingB(G_V2, 97, 246) {
		return false
	}
	return true
}

func r_case_ending(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_p1 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p1
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 1 {
		if !env.EqSB("a") {
			return false
		}
	} else if among_var == 2 {
		if !env.EqSB("e") {
			return false
		}
	} else if among_var == 3 {
		if !env.EqSB("i") {
			return false
		}
	} else if among_var == 4 {
		if !env.EqSB("o") {
			return false
		}
	} else if among_var == 5 {
		if !env.EqSB("\u00E4") {
			return false
		}
	} else if among_var == 6 {
		if !env.EqSB("\u00F6") {
			return false
		}
	} else if among_var == 7 {
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			var v_4 = env.Limit - env.Cursor
		lab1:
			for {
				var v_5 = env.Limit - env.Cursor
			lab2:
				for {
					if !r_LONG(env, context) {
						break lab2
					}
					break lab1
				}
				env.Cursor = env.Limit - v_5
				if !env.EqSB("ie") {
					env.Cursor = env.Limit - v_3
					break lab0
				}
				break lab1
			}
			env.Cursor = env.Limit - v_4
			if env.Cursor <= env.LimitBackward {
				env.Cursor = env.Limit - v_3
				break lab0
			}
			env.PrevChar()
			env.Bra = env.Cursor
			break lab0
		}
	} else if among_var == 8 {
		if !env.InGroupingB(G_V1, 97, 246) {
			return false
		}
		if !env.InGroupingB(G_C, 98, 122) {
			return false
		}
	}
	if !env.SliceDel() {
		return false
	}
	context.b_ending_removed = true
	return true
}

func r_other_endings(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_p2 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p2
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 1 {
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			if !env.EqSB("po") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_3
	}
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_i_plural(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if env.Cursor < context.i_p1 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p1
	env.Ket = env.Cursor
	if env.FindAmongB(A_8, context) == 0 {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_t_plural(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_p1 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p1
	env.Ket = env.Cursor
	if !env.EqSB("t") {
		env.LimitBackward = v_2
		return false
	}
	env.Bra = env.Cursor
	var v_3 = env.Limit - env.Cursor
	if !env.InGroupingB(G_V1, 97, 246) {
		env.LimitBackward = v_2
		return false
	}
	env.Cursor = env.Limit - v_3
	if !env.SliceDel() {
		return false
	}
	env.LimitBackward = v_2
	if env.Cursor < context.i_p2 {
		return false
	}
	var v_5 = env.LimitBackward
	env.LimitBackward = context.i_p2
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_9, context)
	if among_var == 0 {
		env.LimitBackward = v_5
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_5
	if among_var == 1 {
		var v_6 = env.Limit - env.Cursor
	lab0:
		for {
			if !env.EqSB("po") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_6
	}
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_tidy(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if env.Cursor < context.i_p1 {
		return false
	}
	var v_2 = env.LimitBackward
	env.LimitBackward = context.i_p1
	var v_3 = env.Limit - env.Cursor
lab0:
	for {
		var v_4 = env.Limit - env.Cursor
		if !r_LONG(env, context) {
			break lab0
		}
		env.Cursor = env.Limit - v_4
		env.Ket = env.Cursor
		if env.Cursor <= env.LimitBackward {
			break lab0
		}
		env.PrevChar()
		env.Bra = env.Cursor
		if !env.SliceDel() {
			return false
		}
		break lab0
	}
	env.Cursor = env.Limit - v_3
	var v_5 = env.Limit - env.Cursor
lab1:
	for {
		env.Ket = env.Cursor
		if !env.InGroupingB(G_AEI, 97, 228) {
			break lab1
		}
		env.Bra = env.Cursor
		if !env.InGroupingB(G_C, 98, 122) {
			break lab1
		}
		if !env.SliceDel() {
			return false
		}
		break lab1
	}
	env.Cursor = env.Limit - v_5
	var v_6 = env.Limit - env.Cursor
lab2:
	for {
		env.Ket = env.Cursor
		if !env.EqSB("j") {
			break lab2
		}
		env.Bra = env.Cursor
	lab3:
		for {
			var v_7 = env.Limit - env.Cursor
		lab4:
			for {
				if !env.EqSB("o") {
					break lab4
				}
				break lab3
			}
			env.Cursor = env.Limit - v_7
			if !env.EqSB("u") {
				break lab2
			}
			break lab3
		}
		if !env.SliceDel() {
			return false
		}
		break lab2
	}
	env.Cursor = env.Limit - v_6
	var v_8 = env.Limit - env.Cursor
lab5:
	for {
		env.Ket = env.Cursor
		if !env.EqSB("o") {
			break lab5
		}
		env.Bra = env.Cursor
		if !env.EqSB("j") {
			break lab5
		}
		if !env.SliceDel() {
			return false
		}
		break lab5
	}
	env.Cursor = env.Limit - v_8
	env.LimitBackward = v_2
golab6:
	for {
		var v_9 = env.Limit - env.Cursor
	lab7:
		for {
			if !env.OutGroupingB(G_V1, 97, 246) {
				break lab7
			}
			env.Cursor = env.Limit - v_9
			break golab6
		}
		env.Cursor = env.Limit - v_9
		if env.Cursor <= env.LimitBackward {
			return false
		}
		env.PrevChar()
	}
	env.Ket = env.Cursor
	if !env.InGroupingB(G_C, 98, 122) {
		return false
	}
	env.Bra = env.Cursor
	context.S_x = env.SliceTo()
	if context.S_x == "" {
		return false
	}
	if !env.EqSB(context.S_x) {
		return false
	}
	if !env.SliceDel() {
		return false
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		b_ending_removed: false,
		S_x:              "",
		i_p2:             0,
		i_p1:             0,
	}
	_ = context
	var v_1 = env.Cursor
	r_mark_regions(env, context)
	env.Cursor = v_1
	context.b_ending_removed = false
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_2 = env.Limit - env.Cursor
	r_particle_etc(env, context)
	env.Cursor = env.Limit - v_2
	var v_3 = env.Limit - env.Cursor
	r_possessive(env, context)
	env.Cursor = env.Limit - v_3
	var v_4 = env.Limit - env.Cursor
	r_case_ending(env, context)
	env.Cursor = env.Limit - v_4
	var v_5 = env.Limit - env.Cursor
	r_other_endings(env, context)
	env.Cursor = env.Limit - v_5
lab0:
	for {
	lab1:
		for {
			if !context.b_ending_removed {
				break lab1
			}
			var v_7 = env.Limit - env.Cursor
			r_i_plural(env, context)
			env.Cursor = env.Limit - v_7
			break lab0
		}
		var v_8 = env.Limit - env.Cursor
		r_t_plural(env, context)
		env.Cursor = env.Limit - v_8
		break lab0
	}
	var v_9 = env.Limit - env.Cursor
	r_tidy(env, context)
	env.Cursor = env.Limit - v_9
	env.Cursor = env.LimitBackward
	return true
}
