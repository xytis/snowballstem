//! Generated by Snowball 2.0.0 - https://snowballstem.org/

package hungarian

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "cs", A: -1, B: -1, F: nil},
	{Str: "dzs", A: -1, B: -1, F: nil},
	{Str: "gy", A: -1, B: -1, F: nil},
	{Str: "ly", A: -1, B: -1, F: nil},
	{Str: "ny", A: -1, B: -1, F: nil},
	{Str: "sz", A: -1, B: -1, F: nil},
	{Str: "ty", A: -1, B: -1, F: nil},
	{Str: "zs", A: -1, B: -1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "\u00E1", A: -1, B: 1, F: nil},
	{Str: "\u00E9", A: -1, B: 2, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "bb", A: -1, B: -1, F: nil},
	{Str: "cc", A: -1, B: -1, F: nil},
	{Str: "dd", A: -1, B: -1, F: nil},
	{Str: "ff", A: -1, B: -1, F: nil},
	{Str: "gg", A: -1, B: -1, F: nil},
	{Str: "jj", A: -1, B: -1, F: nil},
	{Str: "kk", A: -1, B: -1, F: nil},
	{Str: "ll", A: -1, B: -1, F: nil},
	{Str: "mm", A: -1, B: -1, F: nil},
	{Str: "nn", A: -1, B: -1, F: nil},
	{Str: "pp", A: -1, B: -1, F: nil},
	{Str: "rr", A: -1, B: -1, F: nil},
	{Str: "ccs", A: -1, B: -1, F: nil},
	{Str: "ss", A: -1, B: -1, F: nil},
	{Str: "zzs", A: -1, B: -1, F: nil},
	{Str: "tt", A: -1, B: -1, F: nil},
	{Str: "vv", A: -1, B: -1, F: nil},
	{Str: "ggy", A: -1, B: -1, F: nil},
	{Str: "lly", A: -1, B: -1, F: nil},
	{Str: "nny", A: -1, B: -1, F: nil},
	{Str: "tty", A: -1, B: -1, F: nil},
	{Str: "ssz", A: -1, B: -1, F: nil},
	{Str: "zz", A: -1, B: -1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "al", A: -1, B: 1, F: nil},
	{Str: "el", A: -1, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ba", A: -1, B: -1, F: nil},
	{Str: "ra", A: -1, B: -1, F: nil},
	{Str: "be", A: -1, B: -1, F: nil},
	{Str: "re", A: -1, B: -1, F: nil},
	{Str: "ig", A: -1, B: -1, F: nil},
	{Str: "nak", A: -1, B: -1, F: nil},
	{Str: "nek", A: -1, B: -1, F: nil},
	{Str: "val", A: -1, B: -1, F: nil},
	{Str: "vel", A: -1, B: -1, F: nil},
	{Str: "ul", A: -1, B: -1, F: nil},
	{Str: "b\u0151l", A: -1, B: -1, F: nil},
	{Str: "r\u0151l", A: -1, B: -1, F: nil},
	{Str: "t\u0151l", A: -1, B: -1, F: nil},
	{Str: "n\u00E1l", A: -1, B: -1, F: nil},
	{Str: "n\u00E9l", A: -1, B: -1, F: nil},
	{Str: "b\u00F3l", A: -1, B: -1, F: nil},
	{Str: "r\u00F3l", A: -1, B: -1, F: nil},
	{Str: "t\u00F3l", A: -1, B: -1, F: nil},
	{Str: "\u00FCl", A: -1, B: -1, F: nil},
	{Str: "n", A: -1, B: -1, F: nil},
	{Str: "an", A: 19, B: -1, F: nil},
	{Str: "ban", A: 20, B: -1, F: nil},
	{Str: "en", A: 19, B: -1, F: nil},
	{Str: "ben", A: 22, B: -1, F: nil},
	{Str: "k\u00E9ppen", A: 22, B: -1, F: nil},
	{Str: "on", A: 19, B: -1, F: nil},
	{Str: "\u00F6n", A: 19, B: -1, F: nil},
	{Str: "k\u00E9pp", A: -1, B: -1, F: nil},
	{Str: "kor", A: -1, B: -1, F: nil},
	{Str: "t", A: -1, B: -1, F: nil},
	{Str: "at", A: 29, B: -1, F: nil},
	{Str: "et", A: 29, B: -1, F: nil},
	{Str: "k\u00E9nt", A: 29, B: -1, F: nil},
	{Str: "ank\u00E9nt", A: 32, B: -1, F: nil},
	{Str: "enk\u00E9nt", A: 32, B: -1, F: nil},
	{Str: "onk\u00E9nt", A: 32, B: -1, F: nil},
	{Str: "ot", A: 29, B: -1, F: nil},
	{Str: "\u00E9rt", A: 29, B: -1, F: nil},
	{Str: "\u00F6t", A: 29, B: -1, F: nil},
	{Str: "hez", A: -1, B: -1, F: nil},
	{Str: "hoz", A: -1, B: -1, F: nil},
	{Str: "h\u00F6z", A: -1, B: -1, F: nil},
	{Str: "v\u00E1", A: -1, B: -1, F: nil},
	{Str: "v\u00E9", A: -1, B: -1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "\u00E1n", A: -1, B: 2, F: nil},
	{Str: "\u00E9n", A: -1, B: 1, F: nil},
	{Str: "\u00E1nk\u00E9nt", A: -1, B: 2, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "stul", A: -1, B: 1, F: nil},
	{Str: "astul", A: 0, B: 1, F: nil},
	{Str: "\u00E1stul", A: 0, B: 2, F: nil},
	{Str: "st\u00FCl", A: -1, B: 1, F: nil},
	{Str: "est\u00FCl", A: 3, B: 1, F: nil},
	{Str: "\u00E9st\u00FCl", A: 3, B: 3, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "\u00E1", A: -1, B: 1, F: nil},
	{Str: "\u00E9", A: -1, B: 1, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "k", A: -1, B: 3, F: nil},
	{Str: "ak", A: 0, B: 3, F: nil},
	{Str: "ek", A: 0, B: 3, F: nil},
	{Str: "ok", A: 0, B: 3, F: nil},
	{Str: "\u00E1k", A: 0, B: 1, F: nil},
	{Str: "\u00E9k", A: 0, B: 2, F: nil},
	{Str: "\u00F6k", A: 0, B: 3, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	{Str: "\u00E9i", A: -1, B: 1, F: nil},
	{Str: "\u00E1\u00E9i", A: 0, B: 3, F: nil},
	{Str: "\u00E9\u00E9i", A: 0, B: 2, F: nil},
	{Str: "\u00E9", A: -1, B: 1, F: nil},
	{Str: "k\u00E9", A: 3, B: 1, F: nil},
	{Str: "ak\u00E9", A: 4, B: 1, F: nil},
	{Str: "ek\u00E9", A: 4, B: 1, F: nil},
	{Str: "ok\u00E9", A: 4, B: 1, F: nil},
	{Str: "\u00E1k\u00E9", A: 4, B: 3, F: nil},
	{Str: "\u00E9k\u00E9", A: 4, B: 2, F: nil},
	{Str: "\u00F6k\u00E9", A: 4, B: 1, F: nil},
	{Str: "\u00E9\u00E9", A: 3, B: 2, F: nil},
}

var A_10 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 1, F: nil},
	{Str: "ja", A: 0, B: 1, F: nil},
	{Str: "d", A: -1, B: 1, F: nil},
	{Str: "ad", A: 2, B: 1, F: nil},
	{Str: "ed", A: 2, B: 1, F: nil},
	{Str: "od", A: 2, B: 1, F: nil},
	{Str: "\u00E1d", A: 2, B: 2, F: nil},
	{Str: "\u00E9d", A: 2, B: 3, F: nil},
	{Str: "\u00F6d", A: 2, B: 1, F: nil},
	{Str: "e", A: -1, B: 1, F: nil},
	{Str: "je", A: 9, B: 1, F: nil},
	{Str: "nk", A: -1, B: 1, F: nil},
	{Str: "unk", A: 11, B: 1, F: nil},
	{Str: "\u00E1nk", A: 11, B: 2, F: nil},
	{Str: "\u00E9nk", A: 11, B: 3, F: nil},
	{Str: "\u00FCnk", A: 11, B: 1, F: nil},
	{Str: "uk", A: -1, B: 1, F: nil},
	{Str: "juk", A: 16, B: 1, F: nil},
	{Str: "\u00E1juk", A: 17, B: 2, F: nil},
	{Str: "\u00FCk", A: -1, B: 1, F: nil},
	{Str: "j\u00FCk", A: 19, B: 1, F: nil},
	{Str: "\u00E9j\u00FCk", A: 20, B: 3, F: nil},
	{Str: "m", A: -1, B: 1, F: nil},
	{Str: "am", A: 22, B: 1, F: nil},
	{Str: "em", A: 22, B: 1, F: nil},
	{Str: "om", A: 22, B: 1, F: nil},
	{Str: "\u00E1m", A: 22, B: 2, F: nil},
	{Str: "\u00E9m", A: 22, B: 3, F: nil},
	{Str: "o", A: -1, B: 1, F: nil},
	{Str: "\u00E1", A: -1, B: 2, F: nil},
	{Str: "\u00E9", A: -1, B: 3, F: nil},
}

var A_11 = []*snowballRuntime.Among{
	{Str: "id", A: -1, B: 1, F: nil},
	{Str: "aid", A: 0, B: 1, F: nil},
	{Str: "jaid", A: 1, B: 1, F: nil},
	{Str: "eid", A: 0, B: 1, F: nil},
	{Str: "jeid", A: 3, B: 1, F: nil},
	{Str: "\u00E1id", A: 0, B: 2, F: nil},
	{Str: "\u00E9id", A: 0, B: 3, F: nil},
	{Str: "i", A: -1, B: 1, F: nil},
	{Str: "ai", A: 7, B: 1, F: nil},
	{Str: "jai", A: 8, B: 1, F: nil},
	{Str: "ei", A: 7, B: 1, F: nil},
	{Str: "jei", A: 10, B: 1, F: nil},
	{Str: "\u00E1i", A: 7, B: 2, F: nil},
	{Str: "\u00E9i", A: 7, B: 3, F: nil},
	{Str: "itek", A: -1, B: 1, F: nil},
	{Str: "eitek", A: 14, B: 1, F: nil},
	{Str: "jeitek", A: 15, B: 1, F: nil},
	{Str: "\u00E9itek", A: 14, B: 3, F: nil},
	{Str: "ik", A: -1, B: 1, F: nil},
	{Str: "aik", A: 18, B: 1, F: nil},
	{Str: "jaik", A: 19, B: 1, F: nil},
	{Str: "eik", A: 18, B: 1, F: nil},
	{Str: "jeik", A: 21, B: 1, F: nil},
	{Str: "\u00E1ik", A: 18, B: 2, F: nil},
	{Str: "\u00E9ik", A: 18, B: 3, F: nil},
	{Str: "ink", A: -1, B: 1, F: nil},
	{Str: "aink", A: 25, B: 1, F: nil},
	{Str: "jaink", A: 26, B: 1, F: nil},
	{Str: "eink", A: 25, B: 1, F: nil},
	{Str: "jeink", A: 28, B: 1, F: nil},
	{Str: "\u00E1ink", A: 25, B: 2, F: nil},
	{Str: "\u00E9ink", A: 25, B: 3, F: nil},
	{Str: "aitok", A: -1, B: 1, F: nil},
	{Str: "jaitok", A: 32, B: 1, F: nil},
	{Str: "\u00E1itok", A: -1, B: 2, F: nil},
	{Str: "im", A: -1, B: 1, F: nil},
	{Str: "aim", A: 35, B: 1, F: nil},
	{Str: "jaim", A: 36, B: 1, F: nil},
	{Str: "eim", A: 35, B: 1, F: nil},
	{Str: "jeim", A: 38, B: 1, F: nil},
	{Str: "\u00E1im", A: 35, B: 2, F: nil},
	{Str: "\u00E9im", A: 35, B: 3, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 36, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1}

type Context struct {
	i_p1 int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	context.i_p1 = env.Limit
lab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for {
			if !env.InGrouping(G_v, 97, 369) {
				break lab1
			}
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
					if !env.OutGrouping(G_v, 97, 369) {
						break lab3
					}
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
		lab4:
			for {
				var v_3 = env.Cursor
			lab5:
				for {
					if env.FindAmong(A_0, context) == 0 {
						break lab5
					}
					break lab4
				}
				env.Cursor = v_3
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
				break lab4
			}
			context.i_p1 = env.Cursor
			break lab0
		}
		env.Cursor = v_1
		if !env.OutGrouping(G_v, 97, 369) {
			return false
		}
	golab6:
		for {
		lab7:
			for {
				if !env.InGrouping(G_v, 97, 369) {
					break lab7
				}
				break golab6
			}
			if env.Cursor >= env.Limit {
				return false
			}
			env.NextChar()
		}
		context.i_p1 = env.Cursor
		break lab0
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_v_ending(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_1, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_double(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var v_1 = env.Limit - env.Cursor
	if env.FindAmongB(A_2, context) == 0 {
		return false
	}
	env.Cursor = env.Limit - v_1
	return true
}

func r_undouble(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if env.Cursor <= env.LimitBackward {
		return false
	}
	env.PrevChar()
	env.Ket = env.Cursor
	{
		var c = env.ByteIndexForHop(-(1))
		if int32(env.LimitBackward) > c || c > int32(env.Limit) {
			return false
		}
		env.Cursor = int(c)
	}
	env.Bra = env.Cursor
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_instrum(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_3, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if !r_double(env, context) {
		return false
	}
	if !env.SliceDel() {
		return false
	}
	if !r_undouble(env, context) {
		return false
	}
	return true
}

func r_case(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_4, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if !env.SliceDel() {
		return false
	}
	if !r_v_ending(env, context) {
		return false
	}
	return true
}

func r_case_special(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_5, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("a") {
			return false
		}
	}
	return true
}

func r_case_other(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_factive(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Ket = env.Cursor
	if env.FindAmongB(A_7, context) == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if !r_double(env, context) {
		return false
	}
	if !env.SliceDel() {
		return false
	}
	if !r_undouble(env, context) {
		return false
	}
	return true
}

func r_plural(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_8, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_owned(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_9, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("a") {
			return false
		}
	}
	return true
}

func r_sing_owner(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_10, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_plur_owner(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_11, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	if !r_R1(env, context) {
		return false
	}
	if among_var == 1 {
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p1: 0,
	}
	_ = context
	var v_1 = env.Cursor
	r_mark_regions(env, context)
	env.Cursor = v_1
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_2 = env.Limit - env.Cursor
	r_instrum(env, context)
	env.Cursor = env.Limit - v_2
	var v_3 = env.Limit - env.Cursor
	r_case(env, context)
	env.Cursor = env.Limit - v_3
	var v_4 = env.Limit - env.Cursor
	r_case_special(env, context)
	env.Cursor = env.Limit - v_4
	var v_5 = env.Limit - env.Cursor
	r_case_other(env, context)
	env.Cursor = env.Limit - v_5
	var v_6 = env.Limit - env.Cursor
	r_factive(env, context)
	env.Cursor = env.Limit - v_6
	var v_7 = env.Limit - env.Cursor
	r_owned(env, context)
	env.Cursor = env.Limit - v_7
	var v_8 = env.Limit - env.Cursor
	r_sing_owner(env, context)
	env.Cursor = env.Limit - v_8
	var v_9 = env.Limit - env.Cursor
	r_plur_owner(env, context)
	env.Cursor = env.Limit - v_9
	var v_10 = env.Limit - env.Cursor
	r_plural(env, context)
	env.Cursor = env.Limit - v_10
	env.Cursor = env.LimitBackward
	return true
}
